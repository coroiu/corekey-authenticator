/// <reference lib="webworker" />
/* eslint-disable no-restricted-globals */
import "workbox-precaching";

import { Endpoint, expose, proxy } from "comlink";

import { CryptoModuleBuilder } from "./modules/crypto";
import { precacheAndRoute } from "workbox-precaching";

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.

// import { clientsClaim } from 'workbox-core';
// import { ExpirationPlugin } from 'workbox-expiration';
// import { isComlinkInitMessage } from "./common/messages/comlink";
// import { registerRoute } from 'workbox-routing';
// import { StaleWhileRevalidate } from 'workbox-strategies';

declare const self: ServiceWorkerGlobalScope;

// eslint-disable-next-line no-restricted-globals, @typescript-eslint/no-unused-vars
const ignored = self.__WB_MANIFEST;

// clientsClaim();

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
precacheAndRoute(self.__WB_MANIFEST);

// // Set up App Shell-style routing, so that all navigation requests
// // are fulfilled with your index.html shell. Learn more at
// // https://developers.google.com/web/fundamentals/architecture/app-shell
// const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$');
// registerRoute(
//   // Return false to exempt requests from being fulfilled by index.html.
//   ({ request, url }: { request: Request; url: URL }) => {
//     // If this isn't a navigation, skip.
//     if (request.mode !== 'navigate') {
//       return false;
//     }

//     // If this is a URL that starts with /_, skip.
//     if (url.pathname.startsWith('/_')) {
//       return false;
//     }

//     // If this looks like a URL for a resource, because it contains
//     // a file extension, skip.
//     if (url.pathname.match(fileExtensionRegexp)) {
//       return false;
//     }

//     // Return true to signal that we want to use the handler.
//     return true;
//   },
//   createHandlerBoundToURL(process.env.PUBLIC_URL + '/index.html')
// );

// // An example runtime caching route for requests that aren't handled by the
// // precache, in this case same-origin .png requests like those from in public/
// registerRoute(
//   // Add in any other file extensions or routing criteria as needed.
//   ({ url }) => url.origin === self.location.origin && url.pathname.endsWith('.png'),
//   // Customize this strategy as needed, e.g., by changing to CacheFirst.
//   new StaleWhileRevalidate({
//     cacheName: 'images',
//     plugins: [
//       // Ensure that once this runtime cache reaches a maximum size the
//       // least-recently used images are removed.
//       new ExpirationPlugin({ maxEntries: 50 }),
//     ],
//   })
// );

class ClientProxy implements Endpoint {
  private listeners: EventListenerOrEventListenerObject[] = [];

  constructor() {
    self.addEventListener("message", this.handleEvent);
  }

  addEventListener(
    type: string,
    listener: EventListenerOrEventListenerObject,
    options?: {}
  ): void {
    this.listeners.push(listener);
  }

  removeEventListener(
    type: string,
    listener: EventListenerOrEventListenerObject,
    options?: {}
  ): void {
    const index = this.listeners.indexOf(listener);
    if (index > -1) {
      this.listeners.splice(index, 1);
    }
  }

  async postMessage(
    message: any,
    transfer: Transferable[] = []
  ): Promise<void> {
    const clients = await self.clients.matchAll({
      includeUncontrolled: true,
    });
    clients.forEach((c) => c.postMessage(message, transfer));
  }

  private handleEvent = (event: ExtendableMessageEvent) => {
    this.listeners.forEach((l) => {
      if ("handleEvent" in l) {
        l.handleEvent(event);
      } else {
        l(event);
      }
    });
  };
}

const cryptoModuleBuilder = new CryptoModuleBuilder();
// cryptoModuleBuilder.withInMemoryAccounts();
cryptoModuleBuilder.withIndexedDbAccounts();
// cryptoModuleBuilder.withOptlibCrypto();
cryptoModuleBuilder.withSubtleCrypto();
const cryptoModule = cryptoModuleBuilder.build();
const cryptoAdapter = cryptoModule.createServiceWorkerAdapter(self);

const modules = {
  crypto: proxy(cryptoAdapter),
} as const;

export type ServiceWorkerModules = typeof modules;

self.addEventListener("message", (event) => {
  // This allows the web app to trigger skipWaiting via
  // registration.waiting.postMessage({type: 'SKIP_WAITING'})
  if (!event.data) return;

  if (event.data && event.data.type === "SKIP_WAITING") {
    self.skipWaiting();
  }
});

expose(modules, new ClientProxy());
